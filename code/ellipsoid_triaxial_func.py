import numpy as np
from scipy import linalg
from matplotlib import pyplot as plt

from fatiando import mesher, gridder, utils

import scipy.special

def ellipsoid (xp,yp,zp,xc,yc,zc,a,b,c,azimuth,delta,gamma,declirem,inclirem,intensity,decT,incT,intT,k):
    '''
    Calculates the three componentes of magnetic field generated by an ellipsoid.
    
    input:
    xp,yp - Origin of the ellipsoid in the geographic coordinate.
    zp - Depth of the the ellipsoid.
    a,b - Minor and major axis, respectively.
    azimuth - angle in relation to the major-axe and the geographic north (0<=alpha<=360, radians).
    delta - Inclination between the major-axe and the horizontal plane (0<=delta<=90, radians).
    gamma - Angle between the intermediate-axe and the vertical projection of the horizontal plane to the
    center of the ellipsoid(radians).
    xc,yc,zc - point in the grid that has the center of the ellipsoid.
    declirem - declination of the remanent vector.
    inclirem - inclination of the remanent vector.
    intensity - intensity of the remanent vector.
    intT - Intensity of the Earth's magnetic field.
    incT - Inclination of the Earth's magnetic field.
    decT - Declination of the Earth's magnetic field.
    k - 3x3 matrix where each line has the intensity, declination and inclination of the three susceptibilities vectors.
    Bx_T, By_T, Bz_T, Tf_T - componentes of magnetic field generated by an ellipsoid and the total-field anomaly.
    '''
    
    center = np.array([xc,yc,zc])
    axis = np.array([a,b,c])
    
    azimuth = np.deg2rad(azimuth)
    delta = np.deg2rad(delta)
    angles = np.array([azimuth+np.pi,delta,gamma])
    
    V = V_e(angles)

    ln, mn, nn = utils.dircos(inclirem, declirem)
    
    lt,mt,nt = utils.dircos(incT, decT)

    k_int = np.array([k[0],k[1],k[2]])
    k_angles = np.deg2rad(np.array([k[3],k[4],k[5]]))

    #isotropic case
    if k_int[0] == (k_int[1] and k_int[2]):
        km = np.diag(k_int)
    #anisotropic case
    else:
        k_angles[0] = k_angles[0]+np.pi
        U = V_e(k_angles)
        km = k_matrix(U,V,np.diag(k_int))
    
    # Ellipsoid cartesian body coordinates
    x1,x2,x3 = x_e (xp,yp,zp,center,V)
    
    # Largest real root of the cubic equation (Lambda)
    lamb,teta,q,p,p2,p1,p0 = lamb_T(axis,x1,x2,x3)
    
    # Derivatves of lambda
    dlambx1,dlambx2,dlambx3 = dlambx_T(axis,x1,x2,x3,lamb)
    
    # Calculate the eliptical integral parameters
    F,E,F2,E2,k,theta_l = legendre_eliptical(axis,lamb)
       
    # Integrals calculations
    A, B, C = potential_integrals(axis,k,theta_l,F,E)
    
    # Earth's field and total body magnetization (including demagnetization) in the body's coordinate
    Ft = F_e (intT,lt,mt,nt,V)
    JN = JN_e (intensity,ln,mn,nn,V)
    N1,N2,N3 = N_desmagT (axis,F2,E2)
    JR = JR_e (km,JN,Ft)
    JRD = JRD_e (km,N1,N2,JR)
    JRD_carte = (V).dot(JRD)
    JRD_ang = utils.vec2ang(JRD_carte)
    
    # Geometry for the magnetic field
    m11,m12,m13,m21,m22,m23,m31,m32,m33, cte, V1, V2, V3 = mx(axis,x1,x2,x3,dlambx1,dlambx2,dlambx3,A,B,C,lamb)
    
    # Components of the magnetic field in the body coordinates
    B1 = B1_e (m11,m12,m13,JRD,axis)
    B2 = B2_e (m21,m22,m23,JRD,axis)
    B3 = B3_e (m31,m32,m33,JRD,axis)

    # Components of the magnetic field in the cartesian coordinates
    Bx = Bx_c (B1,B2,B3,V[0,0],V[0,1],V[0,2])
    By = By_c (B1,B2,B3,V[1,0],V[1,1],V[1,2])
    Bz = Bz_c (B1,B2,B3,V[2,0],V[2,1],V[2,2])
    Tf = (Bx*np.cos(np.deg2rad(incT))*np.cos(np.deg2rad(decT)) + By*np.cos(np.deg2rad(incT))*np.sin(np.deg2rad(decT)) + Bz*np.sin(np.deg2rad(incT)))
    return Bx, By, Bz, Tf
    
def V_e (angles):
    '''
    Builds the matrix of coordinate system change to the center of the ellipsoid. Used for the triaxial 
    and prolate ellipsoids.
        
    input:
    alpha - Azimuth+180 degrees in relation to the major-axe and the geographic north (0<=alpha<=360, radians).
    delta - Inclination between the major-axe and the horizontal plane (0<=delta<=90, radians).
    gamma - Angle between the intermediate-axe and the vertical projection of the horizontal plane to the
    center of the ellipsoid(radians).
      
    output:
    A 3x3 matrix.
    '''
    cos_alpha = np.cos(angles[0])
    sin_alpha = np.sin(angles[0])
    
    cos_delta = np.cos(angles[1])
    sin_delta = np.sin(angles[1])

    cos_gamma = np.cos(angles[2])
    sin_gamma = np.sin(angles[2])

    v1 = np.array([-cos_alpha*cos_delta, 
                      -sin_alpha*cos_delta, 
                      -sin_delta])

    v2 = np.array([ cos_alpha*cos_gamma*sin_delta + sin_alpha*sin_gamma,
                       sin_alpha*cos_gamma*sin_delta - cos_alpha*sin_gamma,
                      -cos_gamma*cos_delta])

    v3 = np.array([ sin_alpha*cos_gamma - cos_alpha*sin_gamma*sin_delta,
                      -cos_alpha*cos_gamma - sin_alpha*sin_gamma*sin_delta,
                       sin_gamma*cos_delta])
    
    V = np.vstack((v1, v2, v3)).T
    
    return V

def legendre_eliptical(axis,lamb):
    '''
    Calculates parameters and the Legendre's normal elliptic integrals of first and second order.
        
    input:
    a, b, c - Major, intermediate and minor axis, respectively.
    lamb - Larger root of the cubic equation: s^3 + p2*s^2 + p1*s + p0 = 0.
        
    output:
    F - Legendre's normal elliptic integrals of first order.
    E - Legendre's normal elliptic integrals of second order.
    F2 - Legendre's normal elliptic integrals of first order (calculus of demagnetization factors).
    E2 - Legendre's normal elliptic integrals of second order (calculus of demagnetization factors).
    k - Legendre's normal elliptic integrals parameter.
    theta_l- Legendre's normal elliptic integrals parameter.        
    '''
    k = np.zeros_like(lamb)
    k1 = ((axis[0]**2-axis[1]**2)/(axis[0]**2-axis[2]**2))**0.5
    k.fill(k1)
    theta_l = np.arcsin(((axis[0]**2-axis[2]**2)/(axis[0]**2+lamb))**0.5)
    theta_l2 = np.arccos(axis[2]/axis[0])
    F = scipy.special.ellipkinc(theta_l, k**2)
    E = scipy.special.ellipeinc(theta_l, k**2)
    F2 = scipy.special.ellipkinc(theta_l2, k1**2)
    E2 = scipy.special.ellipeinc(theta_l2, k1**2)
    return F,E,F2,E2,k,theta_l
    
def potential_integrals(axis,k,theta_l,F,E):
    '''
    Calculates the integrals which is part of the solution of the potential field of an homogeneous ellipsoid (Dirichlet,1839).
        
    input:
    a, b, c - Major, intermediate and minor axis, respectively.
    k - Legendre's normal elliptic integrals parameter.
    theta_l- Legendre's normal elliptic integrals parameter.
    F - Legendre's normal elliptic integrals of first order.
    E - Legendre's normal elliptic integrals of second order.
        
    output:
    A2,B2,C2 - Integrals of the potential field of an homogeneous ellipsoid.        
    '''
        
    A2 = (2/((axis[0]**2-axis[1]**2)*(axis[0]**2-axis[2]**2)**0.5))*(F-E)
    B2 = ((2*(axis[0]**2-axis[2]**2)**0.5)/((axis[0]**2-axis[1]**2)*(axis[1]**2-axis[2]**2)))*(E-((axis[1]**2-axis[2]**2)/(axis[0]**2-axis[2]**2))*F-((k**2*np.sin(theta_l)*np.cos(theta_l))/(1-k**2*np.sin(theta_l)*np.sin(theta_l))**0.5))
    C2 = (2/((axis[1]**2-axis[2]**2)*(axis[0]**2-axis[2]**2)**0.5))*(((np.sin(theta_l)*((1-k**2*np.sin(theta_l)*np.sin(theta_l))**0.5))/np.cos(theta_l))-E)
    return A2,B2,C2

def F_e (intT,lt,mt,nt,V):
    '''
    Change the magnetization vetor of the Earth's field to the body coordinates.
    
    input:
    inten - Intensity of the Earth's magnetic field.
    lt,mt,nt - direction cosines of the Earth's magnetic field.
    l1,l2,l3,m1,m2,m3,n1,n2,n3 - matrix of body coordinates change.
    
    output:
    Ft - The magnetization vetor of the Earth's field to the body coordinates.    
    '''
    F = intT*np.array([[(lt*V[0,0]+mt*V[1,0]+nt*V[2,0])], [(lt*V[0,1]+mt*V[1,1]+nt*V[2,1])], [(lt*V[0,2]+mt*V[1,2]+nt*V[2,2])]])
    return F
    
def JN_e (intensity,ln,mn,nn,V):
    '''
    Changes the remanent magnetization vector to the body coordinate.
        
    input:
    intensity - intensity of remanent vector.
    ln,nn,mn - direction cosines of the remanent magnetization vector.
    V - matrix of conversion.
        
    output:
    JN - Remanent magnetization vector in the body coordinate.         
    '''
    JN = intensity*np.array([[(ln*V[0,0]+mn*V[1,0]+nn*V[2,0])], [(ln*V[0,1]+mn*V[1,1]+nn*V[2,1])], [(ln*V[0,2]+mn*V[1,2]+nn*V[2,2])]])
    return JN

def N_desmagT (axis,F2,E2):
    '''
    Calculates the three demagnetization factor along major, intermediate and minor axis. For the triaxial ellipsoid use.
       
    input:
    a,b,c - Major, intermediate and minor axis, respectively.
    F2, E2 - Lagrange's normal eliptic integrals of first and second order.
      
    output:
    N1, N2, N3 - Major, intermediate and minor demagnetization factors, respectively.        
    '''
        
    N1 = ((4.*np.pi*axis[0]*axis[1]*axis[2])/((axis[0]**2-axis[1]**2)*(axis[0]**2-axis[2]**2)**0.5)) * (F2-E2)
    N2 = (((4.*np.pi*axis[0]*axis[1]*axis[2])*(axis[0]**2-axis[2]**2)**0.5)/((axis[0]**2-axis[1]**2)*(axis[1]**2-axis[2]**2))) * (E2 - ((axis[1]**2-axis[2]**2)/(axis[0]**2-axis[2]**2)) * F2 - ((axis[2]*(axis[0]**2-axis[1]**2))/(axis[0]*axis[1]*(axis[0]**2-axis[2]**2)**0.5)))
    N3 = ((4.*np.pi*axis[0]*axis[1]*axis[2])/((axis[1]**2-axis[2]**2)*(axis[0]**2-axis[2]**2)**0.5)) * (((axis[1]*(axis[0]**2-axis[2]**2)**0.5)/(axis[0]*axis[2])) - E2)
    return N1, N2, N3
    
def k_matrix (U,V,K):
        '''
        Build the susceptibility tensor for the anisotropic case.
        
        Parameters:
        
        * U: array
            Direction cosines of the susceptibilities.
        * V: array
            Matrix of coordinates conversion.
        * K: array
            Diagonal matrix with k1,k2,k3 (intensity of the susceptibilities).
        
        Returns:
        
        * km: array
            Susceptibility tensors matrix.
        '''
        
        km = np.dot(np.dot(np.dot(V.T,U), K), np.dot(U.T,V))
        return km
        
def JR_e (km,JN,Ft):
    '''
    Calculates the resultant magnetization vector without self-demagnetization correction.
    
    input:
    km - matrix of susceptibilities tensor.
    JN - Remanent magnetization
    Ft - Magnetization vetor of the Earth's field in the body coordinates.
    
    output:
    JR - Resultant magnetization vector without self-demagnetization correction.   
    '''
    
    JR = km.dot(Ft) + JN
    return JR
    
def JRD_e (km,N1,N2,JR):
    '''
    Calculates resultant magnetization vector with self-demagnetization correction.
    
    input:
    km - matrix of susceptibilities tensor.
    N1,N2,N3 - Demagnetization factors in relation to a, b and c, respectively.
    JR - resultant magnetization vector without self-demagnetization correction.
    
    output:
    JRD - Resultant magnetization vector without self-demagnetization correction.    
    '''
    
    I = np.identity(3)
    kn0 = km[:,0]*N1
    kn1 = km[:,1]*N2
    kn2 = km[:,2]*N2
    kn = (np.vstack((kn0,kn1,kn2))).T
    A = I + kn
    JRD = (linalg.inv(A)).dot(JR)
    return JRD
    
def x_e (xp,yp,zp,center,V):
    '''
    Calculates the new coordinates with origin at the center of the ellipsoid.

    input:
    xp,yp - Origin of the ellipsoid in the geographic coordinate.
    zp - Depth of the the ellipsoid.
    center - point in the grid that has the center of the ellipsoid.
    V - Matrix of conversion.
        
    output:
    x1, x2, x3 - The three axes of the coordinates.
    '''
    
    x1 = (xp-center[0])*V[0,0]+(yp-center[1])*V[1,0]-(zp+center[2])*V[2,0]
    x2 = (xp-center[0])*V[0,1]+(yp-center[1])*V[1,1]-(zp+center[2])*V[2,1]
    x3 = (xp-center[0])*V[0,2]+(yp-center[1])*V[1,2]-(zp+center[2])*V[2,2]
    return x1, x2, x3
    
def lamb_T (axis,x1,x2,x3):
    '''
    Calculates the larger root of the cubic equation: s^3 + p2*s^2 + p1*s + p0 = 0.
    Used in the triaxial ellipsoid.

    input:
    a, b, c - Major, intermediate and minor axis, respectively.
    x1, x2, x3 - Axis of the body coordinate system.
        
    output:
    lamb - Larger root.
    teta, q, p, p2, p1, p0 - constants of the cubic equation.        
    '''
        
    p0 = (axis[0]*axis[1]*axis[2])**2-(axis[1]*axis[2]*x1)**2-(axis[2]*axis[0]*x2)**2-(axis[0]*axis[1]*x3)**2
    p1 = (axis[0]*axis[1])**2+(axis[1]*axis[2])**2+(axis[2]*axis[0])**2-(axis[1]**2+axis[2]**2)*x1**2-(axis[2]**2+axis[0]**2)*x2**2-(axis[0]**2+axis[1]**2)*x3**2
    p2 = axis[0]**2+axis[1]**2+axis[2]**2-x1**2-x2**2-x3**2
    p = p1-(p2**2)/3.
    q = p0-((p1*p2)/3.)+2*(p2/3.)**3
    p3 = (-q/(2*np.sqrt((-p/3.)**3)))
    for i in range (len(p3)):
        if p3[i] > 1.:
            p3[i] = 1.
    teta = np.arccos(p3)
    lamb = 2.*((-p/3.)**0.5)*np.cos(teta/3.)-(p2/3.)
    return lamb, teta, q, p, p2, p1, p0

def dlambx_T (axis,x1,x2,x3,lamb):
    '''
    Calculates the derivatives of the ellipsoid equation for each body coordinates in realation to lambda.
    Used for the triaxial ellipsoid.
       
    input:
    a, b, c - Major, intermediate and minor axis, respectively.
    x1, x2, x3 - Axis of the body coordinate system.
    lamb - Larger root of the cubic equation: s^3 + p2*s^2 + p1*s + p0 = 0.
       
    output:
    dlambx1,dlambx2,dlambx3 - Derivatives of the ellipsoid equation for each body coordinates in realation to x1,x2 and x3.        
    '''
        
    dlambx1 = (2*x1/(axis[0]**2+lamb))/((x1/(axis[0]**2+lamb))**2+(x2/(axis[1]**2+lamb))**2+((x3/(axis[2]**2+lamb))**2))        
    dlambx2 = (2*x2/(axis[1]**2+lamb))/((x1/(axis[0]**2+lamb))**2+(x2/(axis[1]**2+lamb))**2+((x3/(axis[2]**2+lamb))**2))
    dlambx3 = (2*x3/(axis[2]**2+lamb))/((x1/(axis[0]**2+lamb))**2+(x2/(axis[1]**2+lamb))**2+((x3/(axis[2]**2+lamb))**2))
    return dlambx1, dlambx2, dlambx3   

def mx(axis,x1,x2,x3,dlambx1,dlambx2,dlambx3,A,B,C,lamb):
    '''
    Additional calculations for the ellipsoid magnetic field.
        
    input:
    a, b, c - Major, intermediate and minor axis, respectively.
    x1, x2, x3 - Axis of the body coordinate system.
    A,B,C - Integrals of the potential field of an homogeneous ellipsoid
    lamb - Larger root of the cubic equation: s^3 + p2*s^2 + p1*s + p0 = 0.
        
    output: 
    m11, m12, m13, m21, m22, m23, m31, m32, m33, cte, V1, V2, V3 - calculus for the ellipsoid magnetic field.        
    '''
        
    cte = 1/np.sqrt((axis[0]**2+lamb)*(axis[1]**2+lamb)*(axis[2]**2+lamb))
    V1 = x1/(axis[0]**2+lamb)
    V2 = x2/(axis[1]**2+lamb)
    V3 = x3/(axis[2]**2+lamb)
    m11 = (cte*dlambx1*V1) - A
    m12 = cte*dlambx1*V2
    m13 = cte*dlambx1*V3
    m21 = cte*dlambx2*V1
    m22 = (cte*dlambx2*V2) - B
    m23 = cte*dlambx2*V3
    m31 = cte*dlambx3*V1
    m32 = cte*dlambx3*V2
    m33 = (cte*dlambx3*V3) - C
    return m11, m12, m13, m21, m22, m23, m31, m32, m33, cte, V1, V2, V3

def B1_e (m11,m12,m13,J,axis):
    '''
    Calculates the B1 component of the magnetic field generated by n-ellipsoids in the body coordinates.
    Used in the triaxial ellipsoid.
    
    input:
    m11,m12,m13 - Calculus for the ellipsoid magnetic field.
    J - Resultant magnetization vector without self-demagnetization correction.
    a,b,c - Major, intermediate and minor axis, respectively.
    
    output:
    B1 - The B1 component of the magnetic field generated by n-ellipsoids in the body coordinates.    
    '''
    
    B1 = 2*np.pi*axis[0]*axis[1]*axis[2]*(m11*J[0]+m12*J[1]+m13*J[2])
    return B1

def B2_e (m21,m22,m23,J,axis):
    '''
    Calculates the B2 component of the magnetic field generated by n-ellipsoids in the body coordinates.
    Used in the triaxial ellipsoid.
    
    input:
    m21,m22,m23 - Calculus for the ellipsoid magnetic field.
    J - Resultant magnetization vector without self-demagnetization correction.
    a,b,c - Major, intermediate and minor axis, respectively.
    
    output:
    B2 - The B2 component of the magnetic field generated by n-ellipsoids in the body coordinates.    
    '''
    
    B2 = 2*np.pi*axis[0]*axis[1]*axis[2]*(m21*J[0]+m22*J[1]+m23*J[2])
    return B2
    
def B3_e (m31,m32,m33,J,axis):
    '''
    Calculates the B3 component of the magnetic field generated by n-ellipsoids in the body coordinates.
    Used in the triaxial ellipsoid.
    
    input:
    m31,m32,m33 - Calculus for the ellipsoid magnetic field.
    J - Resultant magnetization vector with self-demagnetization correction.
    a,b,c - Major, intermediate and minor axis, respectively.
    
    output:
    B3 - The B3 component of the magnetic field generated by n-ellipsoids in the body coordinates.    
    '''
    
    B3 = 2*np.pi*axis[0]*axis[1]*axis[2]*(m31*J[0]+m32*J[1]+m33*J[2])
    return B3
    
def Bx_c (B1,B2,B3,l1,l2,l3):
    '''
    Change the X component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    
    input:
    B1,B2,B3 - Components of the magnetic field generated by n-ellipsoids to the body coordinates.
    l1,l2,l3 - Direction cosines for coordinates change.
    
    output:
    Bz - The X component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    '''
    
    Bx = B1*l1+B2*l2+B3*l3
    return Bx

def By_c (B1,B2,B3,m1,m2,m3):
    '''
    Change the Y component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    
    input:
    B1,B2,B3 - Components of the magnetic field generated by n-ellipsoids to the body coordinates.
    m1,m2,m3 - Direction cosines for coordinates change.
    
    output:
    Bz - The Y component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    '''
    
    By = B1*m1+B2*m2+B3*m3
    return By

def Bz_c (B1,B2,B3,n1,n2,n3):
    '''
    Change the Z component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    
    input:
    B1,B2,B3 - Components of the magnetic field generated by n-ellipsoids to the body coordinates.
    n1,n2,n3 - Direction cosines for coordinates change.
    
    output:
    Bz - The Z component of the magnetic field generated by n-ellipsoids to the cartesian coordinates.
    '''
    
    Bz = B1*n1+B2*n2+B3*n3
    return Bz